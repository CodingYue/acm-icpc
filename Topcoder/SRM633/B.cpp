// File Name: B.cpp
// Author: YangYue
// Created Time: Wed Sep 17 23:42:47 2014
//headers 
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <ctime>
#include <string>
#include <queue>
#include <set>
#include <map>
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int,int> PII;
typedef pair<double,double> PDD;
typedef pair<LL, LL>PLL;
typedef pair<LL,int>PLI;

#define lch(n) ((n<<1))
#define rch(n) ((n<<1)+1)
#define lowbit(i) (i&-i)
#define sqr(x) ((x)*(x))
#define fi first
#define se second
#define MP make_pair
#define PB push_back

const int MaxN = 10005;
const int MAXM = 30005;
const int MAXN = 10005;
const double eps = 1e-8;
const double DINF = 1e100;
const int INF = 1000000006;
const LL LINF = 1000000000000000005ll;


struct ARC
{
    int y;
    int c;
    ARC* Next;
    ARC* R;
};

ARC APool[MAXM*2];
ARC* APTop = APool;
ARC* Arc[MAXN];

int insert_arc(int x,int y,int c,int rc=0)
{
    ARC* fore = APTop++;
    fore->y = y; fore->c = c; fore->Next = Arc[x]; Arc[x] = fore;
    ARC* back = APTop++;
    back->y = x; back->c = rc; back->Next = Arc[y]; Arc[y] = back;

    fore->R = back; back->R = fore;
    return 0;
}

int init_arc_ds()
{
    memset(Arc,0,sizeof(Arc));
    APTop = APool;
    return 0;
}

int dis[MAXN];
ARC* curArc[MAXN];
int pre[MAXN];
int gap[MAXN];
// God damn SAP :D
int max_flow(int s,int t,int n)
{
    memset(dis,0,sizeof(dis));
    memset(curArc,0,sizeof(curArc));
    memset(gap,0,sizeof(gap));
    gap[0] = n;

    int maxflow = 0;
    int x = s;
    while(dis[s] < n)
    {
        if(x == t)
        {
            int tflow = INF;
            while(x != s)
            {
                tflow = min(tflow,curArc[pre[x]]->c);
                x = pre[x];
            }
            x = t;
            while(x != s)
            {
                curArc[pre[x]]->c -= tflow;
                curArc[pre[x]]->R->c += tflow;
                x = pre[x];
            }
            maxflow += tflow;
            continue;
        }
        if(!curArc[x]) curArc[x] = Arc[x];
        ARC* ar = curArc[x];
        for(;ar;ar = ar->Next)
        {
            int y = ar->y;
            int c = ar->c;
            if(!c) continue;
            if(dis[y]+1 == dis[x]) break;
        }
        curArc[x] = ar;
        if(!ar)
        {
            // relabel
            int mindis = n+1;
            for(ARC* a = Arc[x];a;a = a->Next) if(a->c) mindis = min(mindis,dis[a->y]+1);
            gap[dis[x]]--;
            if(!gap[dis[x]]) break;
            gap[dis[x] = mindis]++;
            if(x != s) x = pre[x];
        }
        else
        {
            pre[ar->y] = x;
            x = ar->y;
        }
    }
    return maxflow;
}
int n;
int fa1[MaxN], fa2[MaxN];
vector<int> edges1[MaxN], edges2[MaxN];
void dfs(int u, vector<int> *edges, int *fa) {
	for (vector<int> :: iterator it = edges[u].begin(); it != edges[u].end(); ++it) if (fa[u] != *it) {
		fa[*it] = u;
		dfs(*it, edges, fa);
	}
}
class DoubleTree {
public:
	int maximalScore(vector <int> a, vector <int> b, vector <int> c, vector <int> d, vector <int> score) {
		n = a.size()+1;
		for (int i = 0; i < n-1; ++i) {
			edges1[a[i]].push_back(b[i]);
			edges1[b[i]].push_back(a[i]);
			edges2[c[i]].push_back(d[i]);
			edges2[d[i]].push_back(c[i]);
		}
		int ans = INF;
		for (int i = 0; i < n; ++i) {
			init_arc_ds();
			fa1[i] = fa2[i] = -1;

			dfs(i, edges1, fa1);
			dfs(i, edges2, fa2);

			int S = n;
			int T = n+1;
			for (int j = 0; j < n; ++j) {
				if (fa1[j] != -1) insert_arc(j, fa1[j], INF);
				if (fa2[j] != -1) insert_arc(j, fa2[j], INF);
				if (score[j] > 0) insert_arc(S, j, score[j]);
				else insert_arc(j, T, -score[j]);
			}
			ans = min(ans, max_flow(S, T, T+1));
		}
		int sum = 0;
		for (int i = 0; i < n; ++i) if (score[i] > 0) sum += score[i];
		return sum - ans;
	}
};
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, vector <int> p3, vector <int> p4, bool hasAnswer, int p5) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p4.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p4[i];
	}
	cout << "}";
	cout << "]" << endl;
	DoubleTree *obj;
	int answer;
	obj = new DoubleTree();
	clock_t startTime = clock();
	answer = obj->maximalScore(p0, p1, p2, p3, p4);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p5 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p5;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	vector <int> p4;
	int p5;
	
	{
	// ----- test 0 -----
	int t0[] = {0,0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,3,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,3};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,3,2};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {1000,24,100,-200};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 1024;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,3,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,3};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,3,2};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {1000,24,100,200};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 1324;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,3,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,3};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,3,2};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {-1000,-24,-100,-200};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 0;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {0,0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,3,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,3};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,3,2};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {-1000,24,100,200};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 200;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {0,0,1,1,2,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,4,5,6};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,1,1,2,2};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,2,3,4,5,6};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {-3,2,2,-1,2,2,-1};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 5;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {0,0,1,1,2,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1,2,3,4,5,6};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,0,0,0,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {1,2,3,4,5,6};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {-3,2,2,-1,2,2,-1};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 5;
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, true, p5) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
// hehe ~


